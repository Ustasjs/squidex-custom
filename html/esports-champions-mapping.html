<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <script src="https://cloud.squidex.io/scripts/editor-sdk.js"></script>
    <!-- change reat to production version -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- support for JSX in the type="text/babel" sript -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/react-hook-form@6.15.4/dist/index.umd.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

    <link rel="stylesheet" type="text/css" href="https://cloud.squidex.io/build/app.css" />

    <style>
      body {
        background: none;
      }

      #root__title {
        display: none;
      }

      #editor {
        min-height: 350px;
      }

      input, select {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
      }

      .error {
        color: red;
      }

      .form-element {
        margin-bottom: 25px;
        position: relative;
      }

      .form-error {
        position: absolute;
        left: 0;
        top: 23px;
      }

      .flex-wrapper {
        display: flex;
        flex-direction: row;
        justify-content: flex-start;
        align-items: center;
      }

      .champion-data_icon {
        margin-right: 8px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }

    </style>
  </head>

  <body>
    <div id="editor"></div>

    <script type="text/babel">
      const field = new SquidexFormField();

      function getMatchData(region, gameId, gameHash) {
        return fetch(`https://esports.int.mobalytics.gg/api/YFFqpzF7QXbsunj6VyXtn8vxPtY3N6/v1/esports/matches/${region}/${gameId}${gameHash ? `?hash=${gameHash}` : ''}`, {
          method: 'GET',
          mode: 'cors',
        }).then(response => {
          return response.json();
        })
      }

      function getChampions(participants, context) {
        const filterValue = participants.reduce((acc, element) => {
          if (acc === '') {
            return `${element}`;
          }
          acc = `${acc}, ${element}`;
          return acc;
        }, '')
        const filter = `$filter=data/riotId/iv in (${filterValue})`;
        return fetch(`${context.apiUrl}/content/league-v1/champions-v1/?${filter}`, {
          headers: {
            Authorization: `Bearer ${context.user.user.access_token}`,
          },
        }).then(response => {
          return response.json();
        })
      }

      function getPlayers(context) {
        return fetch(`${context.apiUrl}/content/esports-v1/esports-players-v1/`, {
          headers: {
            Authorization: `Bearer ${context.user.user.access_token}`,
          },
        }).then(response => {
          return response.json();
        })
      }

      function championImage(slug) {
        return `https://storage.googleapis.com/cdn.mobalytics.gg/assets/lol/images/dd/champions/icons/${slug.toLowerCase()}.png`;
      }

      const PLACEHOLDER_VALUE = 'placeholder-value';

      function Editor() {
        const squidexFormValue = field.getFormValue();
        const initialValue = _.get(squidexFormValue, 'matchDataMaping.iv');

        const [isDisabled, setIsDisabled] = React.useState(false);
        const [value, setValue] = React.useState(initialValue || undefined);
        const [context, setContext] = React.useState(null);
        const [championsData, setChampionsData] = React.useState(null);
        const [matchData, setMatchData] = React.useState(null);
        const [playersData, setPlayersData] = React.useState(null);
        const [isMatchDataLoading, setIsMatchDataLoading] = React.useState(false);
        const [matchDataError, setMatchDataError] = React.useState(null);
        const [showSaveTableMessage, setShowSaveTableMessage] = React.useState(false);
        const gameHash = _.get(squidexFormValue, 'gameHash.iv');
        const gameId = _.get(squidexFormValue, 'gameId.iv');
        const region = _.get(squidexFormValue, 'region.iv');
        const champion2PlayerMap = _.get(squidexFormValue, 'matchDataMaping.iv.champion2PlayerMap');
        console.log('squidexFormValue', squidexFormValue);
        field.onInit(intializedContext => {
          setContext(intializedContext);
        });

        const initialFormValues = React.useMemo(() => {
          if (champion2PlayerMap) {
            return champion2PlayerMap.reduce((acc, element) => {
              acc[element.championSlug] = element.playerSlug;
              return acc;
            }, {});
          }
          return null;
        }, [champion2PlayerMap])

        const { register, handleSubmit, errors, control } = ReactHookForm.useForm({
          onTouched: () => squidexFormValue.touched(),
        });
        const onSubmit = data => {
          const formattedFormData = Object.entries(data).map(([key, value]) => ({ championSlug: key, playerSlug: value }));
          const fieldValue = {
            matchData,
            champion2PlayerMap: formattedFormData,
          }
          field.valueChanged(fieldValue);
          setShowSaveTableMessage(true);
          console.log('formattedFormData', formattedFormData);
        }

        React.useEffect(function () {
          field.onDisabled(function (disabled) {
            setIsDisabled(disabled);
          });

          field.onValueChanged(function (value) {
            setValue(value);
            setShowSaveTableMessage(false);
          });

          field.onFormValueChanged(() => {setShowSaveTableMessage(false)})
        }, []);
        

        React.useEffect(function () {
          if (context) {
            getPlayers(context)
              .then(parsedPlayers => {
                setPlayersData(parsedPlayers);
              })
              .catch(error => {
                setMatchDataError(error.message);
                console.error(error);
              });
          }
        }, [context]);

        const formattedChampionsData = React.useMemo(function () {
          if (championsData) {
            return championsData.items.map(championData => _.get(championData, 'data.slug.iv'));
          }
          return null;
        }, [championsData]);
        const formattedPlayersData = React.useMemo(function () {
          if (playersData) {
            return playersData.items.map(championData => _.get(championData, 'data.slug.iv'));
          }
          return null;
        }, [playersData]);

        const getMatchDataCallback = React.useCallback(() => {
          if (gameId && region && context) {
            setIsMatchDataLoading(true);
            Promise.all([getMatchData(region, gameId, gameHash), getPlayers(context)])
              .then(([parsedMatchData, parsedPlayersData]) => {
                setMatchData(parsedMatchData);
                setPlayersData(parsedPlayersData);
                const participants = _.get(parsedMatchData, 'Data.participants');
                return participants.map(participant => participant.championId);
              })
              .then(participants => {
                return getChampions(participants, context);
              })
              .then(parsedData => {
                setIsMatchDataLoading(false);
                setChampionsData(parsedData);
              })
              .catch(error => {
                setMatchDataError(error.message);
                console.error(error);
              });
          }  
        }, [gameId, gameHash, region, context]);


        const onClearData = React.useCallback(() => {
          field.valueChanged(null);
          setShowSaveTableMessage(true);
        }, [setShowSaveTableMessage]);

        if (!gameId || !region) {
          return (
            <div>Please fill out all required fields</div>
          );
        }

        if (matchDataError) {
          return ( <div className="error">
            <div>Oops, something went wrong!</div>
            <div>{matchDataError}</div>
          </div>)
        }

        if (initialFormValues) {
          return (<div>
            <div className="form-element">
              {Object.entries(initialFormValues).map(([champion, player]) => (
                <div className="flex-wrapper" key={champion}>
                  <span className="flex-wrapper">
                    <img src={championImage(champion)} className="champion-data_icon"/>
                    <span>{champion}</span>
                  </span>
                  <span style={{ margin: '10px' }}>-</span>
                  <span>{player}</span>
                </div>
              ))}
            </div>
            <button onClick={onClearData} type="button">Clear data</button>
          </div>)
        }

        if (!championsData || !matchData) {
          return (
            <div>
              <button onClick={getMatchDataCallback} disabled={isMatchDataLoading} type="button">Load match data</button>
              {isMatchDataLoading && <div>'loading...'</div>}
            </div>
        )}

        return (formattedChampionsData) && (
          <form onSubmit={handleSubmit(onSubmit)}>
            {formattedChampionsData.map(champion => (
              <div key={champion}>
                <div className="form-element">
                  <div className="flex-wrapper">
                    <span  style={{ marginRight: '10px' }} className="flex-wrapper">
                    <img src={championImage(champion)} className="champion-data_icon"/>
                    <span>{champion}</span>
                    </span>
                    <select defaultValue={PLACEHOLDER_VALUE} name={`${champion}`} ref={register({ required: true, validate: value => value !== PLACEHOLDER_VALUE })}>
                      <option key="placeholder" disabled value={PLACEHOLDER_VALUE}> -- select an option -- </option>
                      {formattedPlayersData.map(playerSlug => (
                        <option key={playerSlug} value={playerSlug}>{playerSlug}</option>
                      ))}
                    </select>
                  </div>
                  {errors[champion] && <div className="error form-error">This field is required</div>}
                </div>
              </div>
            ))}
            
            <button type="submit">SAVE</button>
          </form>
        );
      }

      ReactDOM.render(React.createElement(Editor), document.getElementById('editor'));
    </script>
  </body>
</html>
